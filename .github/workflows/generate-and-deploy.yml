name: Generate Beats and Deploy to GitHub Pages

on:
  push:
    branches:
      - main
  schedule:
    # Run daily at 00:00 UTC
    - cron: "0 0 * * *"
  workflow_dispatch: # Allow manual trigger

permissions:
  contents: write
  pages: write
  id-token: write

concurrency:
  group: "pages"
  cancel-in-progress: false

jobs:
  generate-and-deploy:
    runs-on: ubuntu-latest
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Cache cargo registry
        uses: actions/cache@v4
        with:
          path: ~/.cargo/registry
          key: ${{ runner.os }}-cargo-registry-${{ hashFiles('**/Cargo.lock') }}

      - name: Cache cargo index
        uses: actions/cache@v4
        with:
          path: ~/.cargo/git
          key: ${{ runner.os }}-cargo-index-${{ hashFiles('**/Cargo.lock') }}

      - name: Cache cargo build
        uses: actions/cache@v4
        with:
          path: target
          key: ${{ runner.os }}-cargo-build-target-${{ hashFiles('**/Cargo.lock') }}

      - name: Check compilation and run tests
        run: |
          # Ensure code compiles without errors
          cargo check --all-targets
          # Run all tests to catch function signature mismatches
          cargo test --all-targets
          # Note: We allow warnings (dead code, unused imports) but errors will fail the build

      - name: Build project
        run: cargo build --release

      - name: Generate beats
        run: cargo run --release

      - name: Install ffmpeg
        run: |
          sudo apt-get update
          sudo apt-get install -y ffmpeg

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.14"
          cache: "pip"

      - name: Install Python dependencies
        run: |
          pip install -r scripts/requirements.txt

      - name: Create video for YouTube
        run: python3 scripts/create_video.py

      - name: Check if video exists
        id: check_video
        run: |
          if [ -f output/youtube_video.mp4 ]; then
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "Warning: Video file not found, skipping YouTube upload"
          fi

      - name: Upload to YouTube
        if: steps.check_video.outputs.exists == 'true'
        env:
          YOUTUBE_CLIENT_ID: ${{ secrets.YOUTUBE_CLIENT_ID }}
          YOUTUBE_CLIENT_SECRET: ${{ secrets.YOUTUBE_CLIENT_SECRET }}
          YOUTUBE_REFRESH_TOKEN: ${{ secrets.YOUTUBE_REFRESH_TOKEN }}
        run: python3 scripts/upload_youtube.py

      - name: Create docs directory
        run: mkdir -p docs/songs

      - name: Copy song with date and metadata
        run: |
          # Find the newest MP3 and JSON files in output/ (generated with format: {author}_{song_name}_{date})
          MP3_FILE=$(ls -t output/*.mp3 2>/dev/null | head -1)
          JSON_FILE=$(ls -t output/*.json 2>/dev/null | head -1)

          if [ -z "$MP3_FILE" ]; then
            echo "Error: No MP3 file found in output/"
            exit 1
          fi

          # Extract filename without path
          MP3_BASENAME=$(basename "$MP3_FILE")
          JSON_BASENAME=$(basename "$JSON_FILE" 2>/dev/null || echo "")

          # Copy files preserving the original names
          cp "$MP3_FILE" docs/songs/
          if [ -n "$JSON_BASENAME" ] && [ -f "$JSON_FILE" ]; then
            cp "$JSON_FILE" docs/songs/
          fi

          echo "Generated MP3: $MP3_BASENAME"
          if [ -n "$JSON_BASENAME" ]; then
            echo "Metadata: $JSON_BASENAME"
            cat "docs/songs/$JSON_BASENAME"
          fi

      - name: Clean up old songs (keep last 7 songs)
        run: |
          cd docs/songs
          # Group MP3/JSON/WAV pairs by base filename, sort by modification time, keep only 7 most recent
          # This ensures we delete pairs together to avoid orphaned files

          # Get all audio files (MP3 or WAV) sorted by modification time (newest first)
          # Use find to avoid glob expansion issues when no files exist
          find . -maxdepth 1 -type f \( -name "*.mp3" -o -name "*.wav" \) -printf '%T@ %f\n' 2>/dev/null | \
            sort -rn | head -7 | awk '{print $2}' > /tmp/keep_files.txt || touch /tmp/keep_files.txt

          # Extract base names (without extension) of files to keep and create a pattern file for grep
          > /tmp/keep_patterns.txt
          while IFS= read -r audio_file; do
            if [[ -n "$audio_file" ]]; then
              if [[ "$audio_file" == *.mp3 ]]; then
                BASE="${audio_file%.mp3}"
              elif [[ "$audio_file" == *.wav ]]; then
                BASE="${audio_file%.wav}"
              else
                continue
              fi
              echo "^${BASE}$" >> /tmp/keep_patterns.txt
            fi
          done < /tmp/keep_files.txt

          # Delete all MP3 files not in the keep list
          for mp3 in $(find . -maxdepth 1 -type f -name "*.mp3" -printf '%f\n' 2>/dev/null); do
            BASE="${mp3%.mp3}"
            if grep -q "^${BASE}$" /tmp/keep_patterns.txt 2>/dev/null; then
              : # Keep this file
            else
              echo "Deleting old MP3: $mp3"
              rm -f "$mp3"
            fi
          done

          # Delete all WAV files not in the keep list
          for wav in $(find . -maxdepth 1 -type f -name "*.wav" -printf '%f\n' 2>/dev/null); do
            BASE="${wav%.wav}"
            if grep -q "^${BASE}$" /tmp/keep_patterns.txt 2>/dev/null; then
              : # Keep this file
            else
              echo "Deleting old WAV: $wav"
              rm -f "$wav"
            fi
          done

          # Delete all JSON files not in the keep list
          for json in $(find . -maxdepth 1 -type f -name "*.json" -printf '%f\n' 2>/dev/null); do
            BASE="${json%.json}"
            if grep -q "^${BASE}$" /tmp/keep_patterns.txt 2>/dev/null; then
              : # Keep this file
            else
              echo "Deleting old JSON: $json"
              rm -f "$json"
            fi
          done

          rm -f /tmp/keep_files.txt /tmp/keep_patterns.txt

          echo "Songs after cleanup:"
          ls -lh

      - name: Generate songs list JSON
        run: |
          cd docs/songs
          # Create a JSON file with list of available songs (keep only latest 7)
          echo "[" > ../songs.json
          first=true
          count=0
          # Process both MP3 and WAV files, sorted by modification time (newest first)
          # Use find to avoid glob expansion issues
          for file in $(find . -maxdepth 1 -type f \( -name "*.mp3" -o -name "*.wav" \) -printf '%T@ %f\n' 2>/dev/null | sort -rn | head -7 | awk '{print $2}'); do
            if [ $count -ge 7 ]; then
              break
            fi
            if [ "$first" = true ]; then
              first=false
            else
              echo "," >> ../songs.json
            fi
            # Extract date from filename (format: {date}_{author}_{song_name}.{ext})
            # Date is the first part, format YYYY-MM-DD
            date=$(echo "$file" | grep -oE '^[0-9]{4}-[0-9]{2}-[0-9]{2}' | head -1)
            size=$(stat -c%s "$file" 2>/dev/null || echo "0")
            
            # Find corresponding metadata file (same base name but .json)
            if [[ "$file" == *.mp3 ]]; then
              metadata_file="${file%.mp3}.json"
            elif [[ "$file" == *.wav ]]; then
              metadata_file="${file%.wav}.json"
            else
              metadata_file=""
            fi
            
            if [ -n "$metadata_file" ] && [ -f "$metadata_file" ]; then
              # Read name and genre from metadata
              name=$(jq -r '.name // ""' "$metadata_file" 2>/dev/null || echo "")
              genre=$(jq -c '.genre // []' "$metadata_file" 2>/dev/null || echo "[]")
              echo "  {\"filename\": \"$file\", \"date\": \"$date\", \"size\": $size, \"name\": \"$name\", \"genre\": $genre}" >> ../songs.json
            else
              echo "  {\"filename\": \"$file\", \"date\": \"$date\", \"size\": $size}" >> ../songs.json
            fi
            count=$((count + 1))
          done
          echo "" >> ../songs.json
          echo "]" >> ../songs.json
          cat ../songs.json

      - name: Commit and push songs to repository
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git add docs/songs/*.mp3 docs/songs/*.json docs/songs.json
          git diff --staged --quiet || git commit -m "ü•Å Add generated song $(date +%Y-%m-%d)"
          git push

      - name: Setup Pages
        uses: actions/configure-pages@v4

      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: "docs"

      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
