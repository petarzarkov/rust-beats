name: Generate Beats and Deploy to GitHub Pages

on:
  push:
    branches:
      - main
  schedule:
    # Run daily at 00:00 UTC
    - cron: "0 0 * * *"
  workflow_dispatch: # Allow manual trigger

permissions:
  contents: write
  pages: write
  id-token: write

concurrency:
  group: "pages"
  cancel-in-progress: false

jobs:
  generate-and-deploy:
    runs-on: ubuntu-latest
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Cache cargo registry
        uses: actions/cache@v4
        with:
          path: ~/.cargo/registry
          key: ${{ runner.os }}-cargo-registry-${{ hashFiles('**/Cargo.lock') }}

      - name: Cache cargo index
        uses: actions/cache@v4
        with:
          path: ~/.cargo/git
          key: ${{ runner.os }}-cargo-index-${{ hashFiles('**/Cargo.lock') }}

      - name: Cache cargo build
        uses: actions/cache@v4
        with:
          path: target
          key: ${{ runner.os }}-cargo-build-target-${{ hashFiles('**/Cargo.lock') }}

      - name: Check compilation and run tests
        run: |
          # Ensure code compiles without errors
          cargo check --all-targets
          # Run all tests to catch function signature mismatches
          cargo test --all-targets
          # Note: We allow warnings (dead code, unused imports) but errors will fail the build
      
      - name: Build project
        run: cargo build --release

      - name: Generate beats
        run: cargo run --release

      - name: Install ffmpeg
        run: |
          sudo apt-get update
          sudo apt-get install -y ffmpeg

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.14"
          cache: "pip"

      - name: Install Python dependencies
        run: |
          pip install -r scripts/requirements.txt

      - name: Create video for YouTube
        run: python3 scripts/create_video.py

      - name: Check if video exists
        id: check_video
        run: |
          if [ -f output/youtube_video.mp4 ]; then
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "Warning: Video file not found, skipping YouTube upload"
          fi

      - name: Upload to YouTube
        if: steps.check_video.outputs.exists == 'true'
        env:
          YOUTUBE_CLIENT_ID: ${{ secrets.YOUTUBE_CLIENT_ID }}
          YOUTUBE_CLIENT_SECRET: ${{ secrets.YOUTUBE_CLIENT_SECRET }}
          YOUTUBE_REFRESH_TOKEN: ${{ secrets.YOUTUBE_REFRESH_TOKEN }}
        run: python3 scripts/upload_youtube.py

      - name: Create docs directory
        run: mkdir -p docs/songs

      - name: Copy song with date and metadata
        run: |
          # Find the newest MP3 and JSON files in output/ (generated with format: {author}_{song_name}_{date})
          MP3_FILE=$(ls -t output/*.mp3 2>/dev/null | head -1)
          JSON_FILE=$(ls -t output/*.json 2>/dev/null | head -1)

          if [ -z "$MP3_FILE" ]; then
            echo "Error: No MP3 file found in output/"
            exit 1
          fi

          # Extract filename without path
          MP3_BASENAME=$(basename "$MP3_FILE")
          JSON_BASENAME=$(basename "$JSON_FILE" 2>/dev/null || echo "")

          # Copy files preserving the original names
          cp "$MP3_FILE" docs/songs/
          if [ -n "$JSON_BASENAME" ] && [ -f "$JSON_FILE" ]; then
            cp "$JSON_FILE" docs/songs/
          fi

          echo "Generated MP3: $MP3_BASENAME"
          if [ -n "$JSON_BASENAME" ]; then
            echo "Metadata: $JSON_BASENAME"
            cat "docs/songs/$JSON_BASENAME"
          fi

      - name: Clean up old songs (keep last 7 songs)
        run: |
          cd docs/songs
          # Group MP3/JSON pairs by base filename, sort by modification time, keep only 7 most recent
          # This ensures we delete pairs together to avoid orphaned files
          
          # Get all MP3 files sorted by modification time (newest first)
          MP3_FILES=$(ls -t *.mp3 2>/dev/null | head -7 || true)
          
          # Extract base names (without extension) of files to keep
          KEEP_BASES=""
          for mp3 in $MP3_FILES; do
            BASE="${mp3%.mp3}"
            KEEP_BASES="$KEEP_BASES|$BASE"
          done
          
          # Delete all MP3 files not in the keep list
          for mp3 in *.mp3 2>/dev/null; do
            BASE="${mp3%.mp3}"
            if echo "$KEEP_BASES" | grep -q "|$BASE|" || [ -z "$KEEP_BASES" ]; then
              : # Keep this file
            else
              echo "Deleting old MP3: $mp3"
              rm -f "$mp3"
            fi
          done
          
          # Delete all JSON files not in the keep list
          for json in *.json 2>/dev/null; do
            BASE="${json%.json}"
            if echo "$KEEP_BASES" | grep -q "|$BASE|" || [ -z "$KEEP_BASES" ]; then
              : # Keep this file
            else
              echo "Deleting old JSON: $json"
              rm -f "$json"
            fi
          done
          
          echo "Songs after cleanup:"
          ls -lh

      - name: Generate songs list JSON
        run: |
          cd docs/songs
          # Create a JSON file with list of available songs
          echo "[" > ../songs.json
          first=true
          for file in $(ls -t *.mp3 2>/dev/null); do
            if [ "$first" = true ]; then
              first=false
            else
              echo "," >> ../songs.json
            fi
            # Extract date from filename (format: {author}_{song_name}_{date}.mp3)
            # Date is the last part before .mp3, format YYYY-MM-DD
            date=$(echo $file | grep -oE '[0-9]{4}-[0-9]{2}-[0-9]{2}' | tail -1)
            size=$(stat -c%s "$file" 2>/dev/null)
            
            # Find corresponding metadata file (same base name but .json)
            metadata_file="${file%.mp3}.json"
            if [ -f "$metadata_file" ]; then
              # Read name and genre from metadata
              name=$(jq -r '.name // ""' "$metadata_file" 2>/dev/null || echo "")
              genre=$(jq -c '.genre // []' "$metadata_file" 2>/dev/null || echo "[]")
              echo "  {\"filename\": \"$file\", \"date\": \"$date\", \"size\": $size, \"name\": \"$name\", \"genre\": $genre}" >> ../songs.json
            else
              echo "  {\"filename\": \"$file\", \"date\": \"$date\", \"size\": $size}" >> ../songs.json
            fi
          done
          echo "" >> ../songs.json
          echo "]" >> ../songs.json
          cat ../songs.json

      - name: Commit and push songs to repository
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git add docs/songs/*.mp3 docs/songs/*.json docs/songs.json
          git diff --staged --quiet || git commit -m "ü•Å Add generated song $(date +%Y-%m-%d)"
          git push

      - name: Setup Pages
        uses: actions/configure-pages@v4

      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: "docs"

      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
